# Оптимизация прогона тестов
## Описание проблемы
На данный момент прогон тестов для сервиса занимает менее минуты. Для закрепления этого результата в
дальнейшем было решено оптимизировать текущее время прогона тестов и внедрить практики, позволяющие
не позволить деградировать результатам оптимизации прогона тестов.

## Формирование метрики
Для формирования метрики и дальнейшего изучения результатов оптимизации был локально с помощью 
`docker-compose` развернут `InfluxDB` стэк, куда отправляются метрики с прогона тестов.  
За метрику было выбрано общее время прогона всех тестов. На данный момент это 37 секунд. За бюджет 
оптимизации было выбрано время 20 секунд.

## Гарантия работы оптимизируемой программы
Несмотря на то, что покрытие проекта тестами оставляет желать лучшего, на данный момент существует 
588 тестов, написанных с помощью библиотеки `rspec`. С их помощью будет гарантирована корректная 
работа тестов после их оптимизации.

## Feedback-loop
Для оптимизации прогона тестов был разработан следующий `feedback-loop`: Профилирование с помощью 
различных профилировщиков (`test_prof` + `stack_prof`, `rspec --profile`, etc) -> Оптимизация -> 
Проверка работы оптимизированных тестов.

## Поиск точек роста
### Параллельный прогон тестов
Для начала было решено перевести прогон тестов на параллельный прогон тестов. Для этого была 
использована библиотека `parallel_tests`. После исследования вопроса параллельного прогона тестов, 
я пришел к выводу о том, что оптимально будет прогонять тесты в 3 потока, так как дальнейшее 
добавление потоков не приводит к значительному повышению производительности прогона тестов. Для 
прогона тестов был разработан `rake-task` `rake test:run`, который прогоняет тесты в параллельном 
режиме с помощью команды `rake parallel:spec[3]`. После прогона тестов время прогона отправляется в 
локально развернутую `InfluxDB`, где можно наглядно посмотреть результаты оптимизации и заметить 
регрессию, если она наблюдается. Уже на этом этапе тестирование всего тест сьюта стало занимать в 
среднем 25 секунд.

### Оптимизация создания объектов с помощью фабрик
Далее было решено использовать профилирование, предоставляемое библиотекой `rspec`, которое можно 
запустить с помощью команды `rspec --profile`. Оно показало, что наибольшее время занимает 
тестирование консернов. Дальнейшее профилирование с помощью `test_prof` + `stack_prof` показало, что
для всего тест сьюта наибольшей точкой роста является обращение к базе (65%). Так как в основном 
обращения к базе происходят при создании в ней объектов, был сделан вывод о необходимости 
оптимизации фабрик. Также надо было разобраться с тем, почему так долго идут тесты консернов. 
Профилирование с помощью `FPROF=1 rspec spec` показало, что действительно наибольшую часть времени 
(9 секунд из 15) занимает создание объектов фабриками. Также были найдены две фабрики, которые 
создаются чаще всего (8 из 9 секунд). С помощью использования хелпера `let_it_be` количество 
созданий одного из объектов было снижено на 150 раз и таким образом было выиграно 0.7 секунды. 
Далее такой же подход был применен ко второму создаваемому объекту. В результате количество 
созданий этого объекта было снижено на 420 раз и было выиграно 5 секунд. Таким же образом было 
оптимизировано создание третьего объекта. В случае третьего объекта количество его созданий было 
снижено на 60 раз и время было выиграно еще 0.5 секунды. Таким образом время создание объектов с 
помощью фабрик было снижено с 9 до 3.5 секунд. Таким образом было выиграно еще 2 секунды при 
параллельном прогоне тестов и тесты прогоняются 21 секунду.

### Оптимизация тестов консернов
Повторное профилирование с помощью `rspec --profile` показало, что время прогонов тестов консернов 
сократилось, но все еще занимает наибольшее время. stack_prof все еще показывает, что наибольшее 
время (61%) занимает работа с `MySQL`, несмотря на то, что запуск профилирования фабрик показывает, 
что их общее время работы занимает примерно 3.5 секунды, то есть 10-15% от времени прогона всего 
тест сьюта. В связи с этим было решено, что возможно проблема именно в выполнении тестов консернов. 
При их анализе было выявлено, что для их прогона используется библиотека `with_model`, которая с 
`MySQL` в данном случае работает с помощью `database_cleaner` с использованием `truncation`. При 
этом при отключении `database_cleaner` или смены `truncation` на `transaction` тесты работать 
перестают и падают с ошибкой 
`Mysql2::Error: SAVEPOINT active_record_1 does not exist: ROLLBACK TO SAVEPOINT active_record_1`. 
Исследование данного вопроса привело к выводу, что для работы `with_model` с `MySQL` действительно 
необходимо использование стратегии `truncation`. Так как в ближайшее время перехода на `postgresql` 
не планируется, то было решено отказаться от использования `with_model` для изолированного 
юнит-тестирования. Так как во всех случаях для тестирования консернов не было необходимости 
проверять данные в базе, то было решено использовать рубишные классы вида 
`model < ActiveRecord::Base` вместо классов, предоставляемых `with_model`. В результате время 
прогона тест сьюта сократилось до 17 секунд и укладывается в поставленный бюджет оптимизации. Стоит 
заметить, что если было бы необходимо проверять созданные поля в БД, то `with_model` пришлось бы 
оставить и использовать, так что в будущем надо либо переходить на `Postgresql`, либо попробовать 
решить проблему с `with_model` для `MySQL`.

## Результаты оптимизации
В результате проведенной оптимизации время прогона тестов сократилось до 17 секунд, что укладывается 
в бюджет оптимизации. Была создана система для сбора метрик по прогону тестов.